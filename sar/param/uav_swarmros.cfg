#
# Configure endpoint
#
endpoint = {
    name = "drone"        # Possibly non-unique name for the local node
    deviceClass = "drone"   # Discoverable device class
    type = "zyre"           # Endpoint type
    parameters = {          # Endpoint parameters, which for Zyre endpoints can be:
        # ifname = "eth0"       # Network interface to bind to
        # port = 34000          # Port to use for UDP beacons
    }
}

#
# Configure bridged services
#
services = {

    #
    # Telemetry topics
    # 
    # The bridge will subscribe to these topics and forward
    # their latest value to telemetry subscribers.
    #
    #  - source:  the ROS topic that provides the value
    #             for the property - preferably latched
    #  - message: fully qualified name of the underlying
    #             ROS message type
    #  - name:    the discoverable name of the topic
    #  - status:  whether to include the value of this 
    #             property in the status broadcast
    #
    telemetryTopics = (
        {
            source = "telemetry/position", 
            message = "sensor_msgs/NavSatFix",
            name = "position",
            status = true
        },
        {
            source = "telemetry/waypoint", 
            message = "sensor_msgs/NavSatFix",
            name = "waypoint",
            status = true
        },
        {
            source = "mavros/state", 
            message = "mavros_msgs/State",
            name = "autopilotState",
            status = true
        }
    )

    #
    # Outgoing events
    #
    # The bridge will subscribe to these topics and forward
    # received messages as events to the swarm.
    #
    #  - message: fully qualified name of the underlying
    #             ROS message type (must have a field named
    #             header with message type swarmros/EventHeader)
    #  - source:  ROS topic to forward events from
    #
    outgoingEvents = (
        {
            message = "cpswarm_msgs/TargetPositionEvent",
            source = "target_found"
        },
        {
            message = "cpswarm_msgs/TargetGlobalPositionEvent",
            source = "mtool_events/target_found"
        },
        {
            message = "cpswarm_msgs/TargetPositionEvent",
            source = "target_lost"
        },
        {
            message = "cpswarm_msgs/TargetPositionEvent",
            source = "target_update"
        },
        {
            message = "cpswarm_msgs/AreaDivisionEvent",
            source = "area_division"
        },
        {
            message = "cpswarm_msgs/TaskAllocatedEvent",
            source = "cps_selected"
        },
        {
            message = "cpswarm_msgs/TaskOrganizationEvent",
            source = "task_cost/out"
        },
        {
            message = "cpswarm_msgs/Position",
            source = "position"
        },
        {
            message = "cpswarm_msgs/Velocity",
            source = "velocity"
        },
        {
            message = "cpswarm_msgs/StateEvent",
            source = "state"
        },
        {
            message = "cpswarm_msgs/TargetPositionEvent",
            source = "current_pos"
        },
        {
            message = "cpswarm_msgs/TargetPositionEvent",
            source = "target_pos"
        }

    )

    #
    # Incoming events
    #
    # The bridge will listen to these events and republish
    # them under ROS topics.
    #
    # NOTE: Only one handler per event name can be added. If
    #       desired, handlers with the same message type can
    #       republish to the same topic.
    #
    #  - suffix:  will be published under events/<suffix>
    #  - message: fully qualified name of the underlying
    #             ROS message type (must have a field named
    #             header with message type swarmros/EventHeader)
    #  - name:    discoverable event name
    #
    incomingEvents = (
    	{
            suffix = "launch",
            message = "swarmros/SimpleEvent",
            name = "launch"
        },
        {
            suffix = "mission_start",
            message = "swarmros/SimpleEvent",
            name = "missionStart"
        },
        {
            suffix = "mission_abort",
            message = "swarmros/SimpleEvent",
            name = "missionAbort"
        },
        {
            suffix = "mission_stop",
            message = "swarmros/SimpleEvent",
            name = "missionStop"
        },
        {
            suffix = "land",
            message = "swarmros/SimpleEvent",
            name = "land"
        },
        {
            suffix = "target_found",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "target_found"
        },
        {
            suffix = "target_lost",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "target_lost"
        },
        {
            suffix = "target_update",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "target_update"
        },
        {
            suffix = "target_done",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "target_done"
        },
        {
            suffix = "area_division",
            message = "cpswarm_msgs/AreaDivisionEvent",
            name = "area_division"
        },
        {
            suffix = "cps_selection",
            message = "cpswarm_msgs/TaskAllocationEvent",
            name = "cps_selection"
        },
        {
            suffix = "task_cost/in",
            message = "cpswarm_msgs/TaskOrganizationEvent",
            name = "task_organization"
        },
        {
            suffix = "cps_selected",
            message = "cpswarm_msgs/TaskAllocatedEvent",
            name = "cps_selected"
        },
        {
            suffix = "position",
            message = "cpswarm_msgs/Position",
            name = "position"
        },
        {
            suffix = "velocity",
            message = "cpswarm_msgs/Velocity",
            name = "velocity"
        },
        {
            suffix = "state",
            message = "cpswarm_msgs/StateEvent",
            name = "state"
        },
        {
            suffix = "target_gui",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "target_gui"
        },
        {
            suffix = "current_position",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "currentposition"
        },
        {
            suffix = "target_position",
            message = "cpswarm_msgs/TargetPositionEvent",
            name = "targetposition"
        }
    )

    #
    # Published parameters
    #
    # The bridge will load the value of these parameters from
    # the ROS Parameter Server, then publish them both as
    # ROS topics and as remotely available key-value targets.
    #
    # NOTE: Both suffixes and parameter names must be unique. If
    #       desired, two parameter publishers can reference the 
    #       same ROS parameter path. Parameters must have a valid 
    #       value before the bridge is started.
    #
    #  - suffix:  will be published under parameters/<suffix>
    #  - message: fully qualified name of the underlying
    #             ROS message type (can by any type)
    #  - name:    discoverable key-value path
    #  - path:    ROS parameter path
    #  - rw:      whether set requests are accepted
    #
    publishedParameters = (
    #    {
    #        suffix = "reportInterval",
    #        message = "swarmros/UInt",
    #        name = "reportInterval",
    #        path = "example/reportInterval",
    #        rw = true
    #    }
    )

    #
    # Bridged parameters
    #
    # The bridge will load the value of these parameters from
    # the ROS Parameter Server, then publish them as remotely
    # available key-value targets.
    #
    # NOTE: Parameter names must be unique. If desired, two
    #       parameter publishers can reference the same ROS
    #       parameter path. Parameters must have a valid 
    #       value before the bridge is started.
    #
    #  - name:    discoverable key-value path
    #  - path:    ROS parameter path
    #  - rw:      whether set requests are accepted
    #
    bridgedParameters = (
    #    {
    #        name = "exampleBridgedParameter",
    #        path = "example/exampleBridgedParameter",
    #        rw = true
    #    }
    )

}
